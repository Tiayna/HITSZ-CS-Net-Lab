# HITSZ-CS-Net-Lab
Computer Network Lab——Make by HITSZ

哈工大深圳CS计算机网络课程配套实验：手写协议栈部分及邮件客户端部分

一、手写协议栈

代码框架：实验为我们搭建了一套基于TCP/IP模型的协议栈，每一层协议的包头不一样，即每一层的数据包结构不一样，为了支持实现，实验抽象出数据包结构体buf
结构体内容包括有效数据长度len，数据起始地址data（报头指针），负载数据量payload[]，并提供一系列函数接口来进行数据报的类型切换封装等操作，具体实现为
添加协议栈各层包头时前移data指针，移除时后移；此外按照TCP/IP协议规定，网络字节序都是大端字节序，但x86平台上是以小端字节序存储，对于一些uint16类型数据要大小端转换；
同时实验提供了一系列测试案例，通过完成以太网数据帧、ARP协议、IP协议、ICMP协议、UDP协议，自底向上地实现协议类型并进行测试

ETH：
以太网数据包buf的传输路径一般为：网卡->设备驱动层->操作系统内置网络协议栈，现代操作系统提供了获取来自设备驱动层的数据帧的pcap(应用程序编程接口)，代码框架提供了driver.h/c
封装好了类Unix系统下的libpcap库实现pcap，可利用driver中的接口实现从网卡收发数据包；以太网数据帧在网络接口层，要实现数据帧的收发ethernet_out/ethernet_in；

前者要将数据帧发送到驱动层，设置好报头后直接调用driver_send()即可；后者将收到的数据帧中的以太网包头移除后调用net_in()向上层传递即可


ARP:
数据链路层中以MAC硬件地址进行报文传输，而网络通信中用的是IP地址，因此必须建立IP地址和MAC地址的映射关系，即ARP协议(地址解析协议)；
ARP协议以目标IP地址为线索，用来定位应该接收数据包的网络设备的IP地址，具体主要通过arp_req/arp_resp进行请求与响应来实现IP地址的查询并缓存；
实验要求实现：arp_req、arp_resp、arp_in、arp_out函数;

arp_req()/arp_resp()：初始化txbuf后，填写arp报头信息并拷贝进txbuf后调用ethernet_out()广播发送，发送的数据报都属于ARP协议类型，区别在于操作类型字段的不同；

arp_in()：接收到的ARP数据报，进行报头检查后更新ARP表项并查看是否有IP地址对应的arp_buf缓存，若有缓存，说明此前的ARP请求得到响应，则进行ethernet_out()发送IP协议类型的
数据报并移除arp_buf缓存；否则若没有缓存说明收到的ARP数据报为广播请求，检查是否为本机对应的IP地址，是则响应告知本机MAC地址；

arp_out()：对于要发送的ARP数据报，先进行缓存检查查看是否有对应的MAC地址，有则直接ethernet_out发送IP协议类型的数据报，否则再检查是否有arp_buf缓存，仍没有则进行广播请求


IP：
数据链路层提供两个直连设备之间的通信，而跨越数据链路时，就需要借助网络层；实验要求实现IP协议进行IP数据报的接收、分片发送、以及校验和算法实现；

ip_in()：对接收到的IP数据报进行包括：长度、版本号、IP地址、校验和等检查后，移除IP报头，调用net_in向上层传递，如果出现协议类型无法识别，则调用ICMP协议不可达；

ip_fragment_out()：对要发送的数据报(可能是分片)添加IP报头后并填写区分服务、MF/DF标志、生存周期等，调用arp_out()发送即可；

ip_out()：检查要发送的数据报包长是否小于MTU，是则直接调用ip_fragment_out()发送，否则需要进行IP数据报分片，初始化ip_buf大小为1480bytes将数据报包长截断1480bytes，直到最后一个
分片小于或等于MTU，初始化ip_buf大小为该分片大小，设置标志位MF=0后调用ip_fragment_out()发送；

checksum16()：依据算法实现即可


ICMP：
IP协议实现了网络之间跨域通信，但局限性在于无法对差错情况进行处理，ICMP协议弥补了相应缺陷，功能包括：确认IP数据包是否成功送达、通知发送过程IP数据包被废弃的具体原因等；
ICMP协议也属于网际层，主要为差错报文和查询报文两种，其中差错报文的ICMP数据报结构的处理利用了IP数据报报头及数据部分的前8字节(UDP/TCP报头前8字节为端口号)，报头内容的填写
相对于查询报文要额外处理IP数据报部分的内容

icmp_in()：对于收到的icmp数据包，检查TYPE字段和CODE字段是否为回显请求，是则回送一个回显应答icmp_resp()

icmp_resp()：回显应答，初始化txbuf，封装报头和数据，数据部分拷贝接收的回显请求报文中的数据，然后调用ip_out()发送ICMP协议类型的数据报

icmp_unreachable()：初始化txbuf长度为ICMP报头8字节+IP数据报报头20字节+IP数据报数据部分前8字节，前8字节部分手动填写，后28字节直接拷贝收到的ip数据包内容

UDP：
UDP主要用于对高速传输和实时性有较高要求的通信或广播通信，UDP头部为8字节，其校验和字段与IP数据报报头中的校验和算法相同，但需要使用头部前12字节作为UDP伪头部来辅助计算；
其原因是在TCP/IP通信中不能仅仅依靠端口来识别通信(UDP头部)，还需要IP地址与协议号才能够区分不同通信

udp_checksum()：计算校验和时引入伪头部会覆盖掉IP报头，需要暂存，然后再通过udp伪头部报头偏移来计算校验和填入udp报头字段，最后将暂存的IP报头拷贝回去即可

udp_in()：对收到的udp数据报报头进行检查校验后，查询udp_table中有无目的端口号对应的处理函数(类似中断处理函数)，有则调用handler，否则调用icmp_unreachable()发送端口不可达的差错报文

udp_out()：对要发送的udp数据报报头填写(大小端转换)，由于要计算校验和，还需要额外填写IP报头部分内容，填写完后先将udp报头校验和字段设为0后调用udp_checksum()，
将计算结果填入，然后调用ip_out()发送上层协议类型为UDP的IP数据报


二、邮件客户端

邮件客户端实验基于SMTP协议与POP3协议实现邮件通信，还有通过MIME协议实现邮件附件传输图片.jpg等格式文件；客户端与SMTP服务器、POP3服务器通信基于TCP连接建立，利用SOCKET_STREAM
建立起TCP连接，其中包含Socket编程的基本API调用与sockaddr等结构体使用，代码框架封装了要用的base64编码格式转换接口，以及Socket编程的库，详情见代码实现

SMTP协议实现发送端到SMTP服务器、SMTP服务器到SMTP服务器之间的通信传输，主要包括：EHLO初始命令、AUTH登录命令、MAIL FROM发送邮箱地址命令、RCPT TO目的邮箱地址命令、DATA数据传输命令、
QUIT命令结束与SMTP服务器通信

POP3协议实现了接收端拉取POP3服务器的通信传输，主要包括：USER/PASS用户名密码认证命令、STAT邮箱统计信息命令、LIST邮件信息命令、RETR邮件正文命令、DELE删除命令、RSET撤销删除命令、
NOOP命令、QUIT命令结束与POP3服务器通信

MIME协议的提出是为了发送更多的字符及多媒体内容，其做法是在最基础的纯文本消息的格式上增加一些规则与编码规则，以此传送非ASCII码消息，定义了五个邮件头来辅助判断

