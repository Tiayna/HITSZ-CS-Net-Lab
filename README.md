# HITSZ-CS-Net-Lab
Computer Network Lab——Make by HITSZ

哈工大深圳CS计算机网络课程配套实验：手写协议栈部分及邮件客户端部分

一、手写协议栈

代码框架：实验为我们搭建了一套基于TCP/IP模型的协议栈，每一层协议的包头不一样，即每一层的数据包结构不一样，为了支持实现，实验抽象出数据包结构体buf
结构体内容包括有效数据长度len，数据起始地址data（报头指针），负载数据量payload[]，并提供一系列函数接口来进行数据报的类型切换封装等操作，具体实现为
添加协议栈各层包头时前移data指针，移除时后移；此外按照TCP/IP协议规定，网络字节序都是大端字节序，但x86平台上是以小端字节序存储，对于一些uint16类型数据要大小端转换；
同时实验提供了一系列测试案例，通过完成以太网数据帧、ARP协议、IP协议、ICMP协议、UDP协议，自底向上地实现协议类型并进行测试

ETH：
以太网数据包buf的传输路径一般为：网卡->设备驱动层->操作系统内置网络协议栈，现代操作系统提供了获取来自设备驱动层的数据帧的pcap(应用程序编程接口)，代码框架提供了driver.h/c
封装好了类Unix系统下的libpcap库实现pcap，可利用driver中的接口实现从网卡收发数据包；以太网数据帧在网络接口层，要实现数据帧的收发ethernet_out/ethernet_in；
前者要将数据帧发送到驱动层，设置好报头后直接调用driver_send()即可；后者将收到的数据帧中的以太网包头移除后调用net_in()向上层传递即可

ARP:
数据链路层中以MAC硬件地址进行报文传输，而网络通信中用的是IP地址，因此必须建立IP地址和MAC地址的映射关系，即ARP协议(地址解析协议)；
ARP协议以目标IP地址为线索，用来定位应该接收数据包的网络设备的IP地址，具体主要通过arp_req/arp_resp进行请求与响应来实现IP地址的查询并缓存；
实验要求实现：arp_req、arp_resp、arp_in、arp_out函数;
arp_req()/arp_resp()：初始化txbuf后，填写arp报头信息并拷贝进txbuf后调用ethernet_out()广播发送，发送的数据报都属于ARP协议类型，区别在于操作类型字段的不同；
arp_in()：接收到的ARP数据报，进行报头检查后更新ARP表项并查看是否有IP地址对应的arp_buf缓存，若有缓存，说明此前的ARP请求得到响应，则进行ethernet_out()发送IP协议类型的
数据报并移除arp_buf缓存；否则若没有缓存说明收到的ARP数据报为广播请求，检查是否为本机对应的IP地址，是则响应告知本机MAC地址；
arp_out()：对于要发送的ARP数据报，先进行缓存检查查看是否有对应的MAC地址，有则直接ethernet_out发送IP协议类型的数据报，否则再检查是否有arp_buf缓存，仍没有则进行广播请求

IP：


